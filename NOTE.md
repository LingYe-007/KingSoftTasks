**## Note**



#### 2021 7月7日

> \> 哟哟,今天写着Note,昨天学了Node,还看完了Webpack,感觉自己像个geek~

昨天因为mongo只用了解增删查改,之前有用过就没复习。主要是看自己买的书,阿里居玉皓写webpack调优与进阶,终于看完了,有几点我觉得收获比较深：

\- webpack的基本概念。什么chunk,bundle,loader,plugin,WDS,万物皆模块这些就是老生常谈了。热模块刷新倒是一个对我来说不太了解的概念,它实际上是WDS对网页有了一个websocket的长连接,然后你编译后通过chunk的hash值来对比是否刷新,比较关键的是它用了HMR技术来实现局部刷新。

\- 对于软件工程来说,好的优化方案不是说上来就构建,而是项目达到一定规模后再针对性的去优化。

\- 一些优化方案。这里就说一下大体思路吧。

 \- 去除死代码。其实我觉得common.js之所以要被淘汰是因为他是动态的,无法对语言进行静态分析,而ES6 module则是静态的。同时common.js是只是对之前值的一个copy,而ES module则是映射。而对于webpack来说,打包去除没用到的代码就要用到tree-shaking（个人感觉听起来还是比较好用的）

 \- 利用缓存,这个就不说了,common.js它会使用之前的缓存,如果你不刷新的话。同时就是如果能使用缓存就使用缓存,如果你想新发布一个东西,同时让所有用户都不使用之前的缓存,可以直接改变你的资源连接,或是利用chunk的hash值进行版本更新。

 \- 打包范围.什么vendor,exclude,include,代码分片后提取公共部分,noprase,IgnorePrase之类的。

 \- 资源压缩

然后就再看朴灵写的深入浅出Node.js，目前收获:

\- Node的一些运行规则,和Node的背景

\- common.JS的一些规范。

\- NPM包的详细由来与使用方法

就这么多啦

#### 2021 7月8日

> \> 不要想着一蹴而就,要脚踏实地

昨天早上看了会<深入浅出Node.js>,发现自己一旦涉及到操作系统或是C/C++时就看不懂了,还是自己段位不够吧。准备先读iting5的<狼书>，这本好像简单一点。而计算机网络,我觉得还是有一个大体的印象后再去读书会好很多。所以准备看看mooc上的课程。下周之类看完吧。

工作这边就,昨天布置了任务,然后写了几个小时,完成了album的编写吧。不过mongoDB好像连接出了问题。准备今天把这个任务完成。感觉难度并不是很大。

早点写完！不写完就加班！早点下ban

**2021 7月9日**

> \> 加油吧，伍勋高

今天一天就在写老师的任务,只是还没有写完,食言了...主要是我爸妈来看我了,不然一定加班了。

下午领了甜点后好像就开始摸鱼了....一直在看掘金。

周末一定要写完呀...

**周末**

好吧,周末,都再摸鱼。周一一定一定。

#### 7.12 周一

好吧,作业好像比我想象中难许多,今天一天就在嗑这个了,主要是数据库操作出了几个比较傻的错误,耽误了很久,然后现在估计只有用户的测试代码没写了。当然还有过敏之类的问题,还有token失效的问题。

#### 7.21 周二

今天就完成了作业,感觉完成度还可以。还看了小会node.js。准备还是得把他啃完。

#### 7.14 周三

> 不要因为一时的成功而松懈

昨天主要是看了下**hook**的知识,个人感觉其实就是<u>组件微小化,颗粒化理念</u>的一种实践,是类组件的一种简洁进化。但好像对于函数组件来说,我们之前没办法管理函数的创建与结束（对应类组件的生命周期）,局部作用域的变量也得不到保存,函数可以说是*七秒钟的记忆*,所以我们引入**hook**,也就是我们的钩子来做这些事情。我们的**hook**实质上感觉是类组件在函数组件上的扩展。因为它更具有简洁性和方便维护以及自由度高的特点,当然react开发团队也做了许多性能上的优化,这是React开发者需要全面拥抱hook的原因。

类组件的复杂之处在于它需要继承,管理类状态.父子通信与爷孙通信的嵌套会导致类组件越来越复杂,状态管理也越来越复杂（当然也有modux与redux等解决方案),伴随而来的还有类中this的各种指向（感觉this的指向是前端开发者绕不开的,this通俗意义上是指向的就是引用它的.而在类中我们需要手动绑定各种this,因为javascript的执行机制会导致this隐式绑定,然后丢失.）同时你在生命周期里进行一些需要手动清理的操作时,会让你的生命周期函数变得越来繁琐。

对于函数式组件来说,则要轻松很多。我们引入useState来管理状态

```
const [use,useState] = useState('预设值')
```

一般来说退出函数后,变量会被注销。React会对挂载上去的组件进行追踪,同时组件内部又会有'记忆单元格',所以并不是每次加载都会创建我们的state,而是把state放入我们的记忆单元格上,等要取出来的时候再再去查询,这也是useState中use的由来。值得一提的时候,我们并不要像类中使用繁琐的this指向了,而是直接通过数组解构出来的useState方法来给我们use这一单一变量进行设值。

对于类组件的生命周期来说,我们常常在componentDidMount和componentDidUpdate中执行副作用（一些获取数据,更新视图之类的操作),在componentWillUnmount中做一些清除副作用或承接的操作。React提供的另一个Hook useEffer则是合并了这些复杂的生命周期,只需要这样：

```
useEffec(
()=>{在原先生命周期创建的函数中执行的东西,相当于ComponentDidMount与componentDidUpdate}   
return {相当于componentWillUnmount})
```

值得一提的是useEffec的执行时机,每次执行useEffec是在渲染之后,所以()=>{}里的内容是会被多次执行,为了避免事件被重复定义,我们在每次在创建userEffec时,销毁之前的useEffec,由此useEffec和componentWillunmount还是有一些区别。

但如果是这样,我们每次setState都会引起组件的更新,就会破坏我们的预想的一些执行模式,也会影响性能。所以React官方也提供了第二个参数

```
useEffec(
()=>{在原先生命周期创建的函数中执行的东西,相当于ComponentDidMount与componentDidUpdate}   
return {相当于componentWillUnmount},[状态数组]) 
```

当我们什么都没指定的情况下,任何更新都会引起我们函数组件的useEffec的重新创建与卸载。但指定后,React会对指定参数进行监听,我们指定参数发生变化的时候,组件会再次销毁useEffec并创建新的。

也看了下React推出的其他hooks,比如useRef,useContext,useReducer等等,但对于我来说,应用价值并不算太大，等要用的时候再细看。

再说下自定义hook吧:

自定义hook实际上并不是很高大上的东西,它只是我们的一种约定,如果一个函数内部使用了hooks,并且函数名以use开头,那他就是自定义的hook。实际上这种hook就是我们对React中hook的二次封装,在实际的项目当中,我们对一些操作的二次封装能够极大地减小我们的工作量。Do not repeat yourself。

昨天还看了下深入浅出Node.js.主要是buffer和Node的网络应用编程。

buffer实际上就是一种二进制的数据。在网络传输和文件系统中,我们都是利用buffer来传递的,在前端编程的时候我们很少考虑这些,是因为前端很少用到文件系统与网络传输。而Node提供了我们操作这些的能力,buffer的使用就不可避免了。buffer的连接很重要,它不能直接相加,那样会隐式转化成字符串然后出现乱码。正确的姿势是利用buffer.concat,数组拼接的方式。同时buffer支持的编码方式也是有限的,这种时候我们可以利用社区的力量下载一些第三方库帮助我们完成这些事情。

Node的网络应用也学过很多了。主要是TCP这块,因为没看过这块,这段时间在弥补这些基础知识的不足。但在我现在看来，TCP像是一个人给另一个人发消息说在吗,另一个回答在,然后这个人才开始说事情..等等

昨天也看了下mooc上的计算机网络,对于我们的计算机网络,它是通信技术与计算机网络的结合。实际上也是通信网络的特殊化——端也就是我们的host:都是电脑或是电子系列产品。它是由多级ISP组成,然后与区域网连接,当然对竞争对手也由IXP这样的交换网络保证全球网络的通畅。

#### 7.15 周四

昨天因为感觉任务不算太难，就先看了下webpack的运行机制和原理,还有一些用的比较多的loader与plugin。大概有这些:

* 优化方案
* 运行机制
* 运行原理

感觉webpack真的想深入还得下苦功夫,所以买了本深入浅出webpack.

后面继续看了下hook,主要是与class这方面的区别:

* 社区说这个也挺多的,无非就是那几个方面 
  1. 性能
  2. this
  3. 类复杂
  4. 函数是第一公民

后面有杂七杂八看了许多,wobsocket,node.js之类的。

然后晚点就在写任务了,能够顺利运行了,然后开始改写,准备今天写完。




